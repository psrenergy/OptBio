var documenterSearchIndex = {"docs":
[{"location":"process.html#Process","page":"Process","title":"Process","text":"","category":"section"},{"location":"process.html","page":"Process","title":"Process","text":"A process is an operation that transforms a set of input products into a different set of output products, in specific proportions, and it's realized in a plant.  ","category":"page"},{"location":"process.html#Process-Definition","page":"Process","title":"Process Definition","text":"","category":"section"},{"location":"process.html","page":"Process","title":"Process","text":"The user can define a process in the database using the OptBio.add_process! function. All the parameters available are essential for the process definition. The user must pass the database object as the first argument.","category":"page"},{"location":"process.html","page":"Process","title":"Process","text":"OptBio.add_process!(\n    database;\n    label = \"Integrated ethanol production\",\n    opex = 0.6,\n    product_input = [\"Sugarcane\", \"Straw\"],\n    factor_input = [1.0, 0.9],\n    product_output = [\"Ethanol 1G\", \"Ethanol 2G\"],\n    factor_output = [7.5, 6.0],\n)","category":"page"},{"location":"process.html","page":"Process","title":"Process","text":"The opex parameter defines the operational expenditure of the process. It is based on the amount of the first input product that is being processed. In the example above, the operational expenditure is multiplied by the amount of tons of sugarcane processed, and added to the total cost of the operation.","category":"page"},{"location":"process.html","page":"Process","title":"Process","text":"The product_input and product_output parameters define the input and output products of the process, respectively. The factor_input and factor_output parameters define the proportion of each input and output product in the process. In the example above, the process \"Integrated ethanol production\" receives 1 ton of sugarcane and 0.9 tons of straw, and produces 7.5 kL of first-generation ethanol and 6.0 kL of second-generation ethanol.","category":"page"},{"location":"process.html#Linking-Process-to-Plant","page":"Process","title":"Linking Process to Plant","text":"","category":"section"},{"location":"process.html","page":"Process","title":"Process","text":"After defining the process, it is necessary to link it to a plant. The OptBio.set_process_plant! function is used for this purpose. The function receives the database object, the label of the process, and the label of the plant.","category":"page"},{"location":"process.html","page":"Process","title":"Process","text":"OptBio.set_process_plant!(database, \"Integrated ethanol production\", \"Ethanol Plant\")","category":"page"},{"location":"tutorial.html#Getting-started-with-OptBio","page":"Tutorial","title":"Getting started with OptBio","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"This tutorial is aimed at providing a quick introduction to defining bioproducts chains and optimizing its investments and operations using OptBio.","category":"page"},{"location":"tutorial.html#What-is-OptBio?","page":"Tutorial","title":"What is OptBio?","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio is a open-source optimization library for bioproducts chains. It is built on top of JuMP. It allows users to define a bioproducts chain, including products, processes and plants, and optimize the investments and operations of the chain.","category":"page"},{"location":"tutorial.html#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio is a package for Julia. To install it, you need to have Julia installed on your computer. To install Julia, please visit the Julia website. After installing Julia, you can install OptBio:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Clone the repository:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"git clone https://github.com/psrenergy/OptBio.git","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Navigate to the package directory and activate the project environment:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"cd OptBio\njulia --project","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once in the Julia REPL, instantiate the environment to set up the necessary dependencies:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia> import Pkg\n\njulia> Pkg.instantiate()","category":"page"},{"location":"tutorial.html#An-example","page":"Tutorial","title":"An example","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In this example, we will define a simple bioproducts chain based on sugarcane and its straw. The chain will include a sugar mill and an ethanol plant. The sugar mill will produce sugar from sugarcane, and the ethanol plant will produce first and second generation ethanol from sugarcane and straw. Attributes of each of these elements will be defined, and also the relationships between them.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using OptBio\n\nfilename = \"my_optbio_case_folder/my_chain.optbio\"\ndatabase = OptBio.create_case(filename)\n\nOptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    sell_price = 5000.0,\n    unit = \"t\",\n)\n\nOptBio.add_product!(\n    database;\n    label = \"Sugarcane\",\n    unit = \"t\",\n    initial_availability = 100.0,\n)\n\nOptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 52000.0,\n)\n\nOptBio.add_process!(\n    database;\n    label = \"Sugar Mill\",\n    opex = 0.0,\n    product_input = [\"Sugarcane\"],\n    factor_input = [1.0],\n    product_output = [\"Sugar\"],\n    factor_output = [0.75],\n)\n\nOptBio.set_process_plant!(database, \"Sugar Mill\", \"Sugar Mill\")\n\nOptBio.add_product!(\n    database;\n    label = \"Straw\",\n    unit = \"t\",\n    initial_availability = 100.0,\n)\n\nOptBio.add_product!(\n    database;\n    label = \"Ethanol 1G\",\n    unit = \"kL\",\n    sell_price = 0.5,\n)\n\nOptBio.add_product!(\n    database;\n    label = \"Ethanol 2G\",\n    unit = \"kL\",\n    sell_price = 0.7,\n)\n\nOptBio.add_plant!(\n    database;\n    label = \"Ethanol Plant\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n)\n\nOptBio.add_process!(\n    database;\n    label = \"Integrated ethanol production\",\n    opex = 0.0,\n    product_input = [\"Sugarcane\", \"Straw\"],\n    factor_input = [1.0, 0.9],\n    product_output = [\"Ethanol 1G\", \"Ethanol 2G\"],\n    factor_output = [7.5, 6.0],\n)\n\nOptBio.set_process_plant!(database, \"Integrated ethanol production\", \"Ethanol Plant\")\n\nOptBio.close_database!(database)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"After running this code, a file named my_chain.optbio will be created in the folder my_optbio_case_folder. This file will be used by OptBio to extract the information about the bioproducts chain, build the optimization problem and solve it.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia> inputs, solution = OptBio.main([filename]);\n\njulia> @show solution[\"capacity\"];\nsolution[\"capacity\"] = [100.0, 0.0]\n\njulia> @show solution[\"investment\"];\nsolution[\"investment\"] = [52000.0, 0.0]\n\njulia> @show solution[\"sell\"];\nsolution[\"sell\"] = [75.0; 0.0; 0.0; 0.0; 0.0;;]","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"After running the OptBio optimization, a summary of the main results will be available in the solution dictionary. A more detailed report will be available in the folder my_optbio_case_folder/results, including many .csv files with the results of the optimization, the file optbio_dashboard.html with a dashboard of the results, and the file optbio_flowchart.html with a flowchart of the bioproducts chain, with the paths of chosen investments highlighted, as shown in the image below.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(Image: alt text)","category":"page"},{"location":"tutorial.html#Step-by-step","page":"Tutorial","title":"Step-by-step","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once the OptBio package is installed, to use it in your programs write:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using OptBio","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To initialize a new OptBio case, use the create_case function, passing the name of the file where the case will be saved. This function will return a database object that will be used to define the bioproducts chain.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"filename = \"my_optbio_case_folder/my_chain.optbio\"\ndatabase = OptBio.create_case(filename)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Products are defined using the add_product! function. The function receives the database object and some attributes of the product. labeland unit are mandatory attributes. The sell_price attribute is optional and represents the price at which the product is sold. In the code below, we add to the database the product \"Sugar\", which is sold at a price of $5000.0 per ton.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    sell_price = 5000.0,\n    unit = \"t\",\n)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Another attribute that can be defined for a product is the initial_availability, which represents the initial availability of the product in the chain. It is necessary that the root product of the chain has its initial availability defined. In the code below, we add to the database the product \"Sugarcane\", which has an initial availability of 100.0 tons. Also, it has no sell_price attribute, which means that it is not sold.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.add_product!(\n    database;\n    label = \"Sugarcane\",\n    unit = \"t\",\n    initial_availability = 100.0,\n)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Plants are defined using the add_plant! function. The function receives the database object and some attributes of the plant. label, reference_capacity and reference_capex are mandatory attributes. In the code below, we add to the database the plant \"Sugar Mill\", which has a reference capacity of 100.0 tons (unit is based on the first product that will linked to it) and a reference capital expenditure of $52000.0.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 52000.0,\n)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Processes are defined using the add_process! function. As usual, label is a mandatory attribute. Also, the opex attribute must be defined, representing the operational expenditure of the process. The process must have a vector of input products, defined by the product_input attribute, and a vector of output products, defined by the product_output attribute. The factor_input and factor_output attributes represent the proportion of each input and output product in the process. In the code below, we add to the database the process \"Sugar Mill\", which has no operational expenditure, and produces 0.75 tons of sugar for each ton of sugarcane processed.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.add_process!(\n    database;\n    label = \"Sugar Mill\",\n    opex = 0.0,\n    product_input = [\"Sugarcane\"],\n    factor_input = [1.0],\n    product_output = [\"Sugar\"],\n    factor_output = [0.75],\n)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The set_process_plant! function is used to link a process to a plant. The function receives the database object, the label of the process and the label of the plant. In the code below, we link the process \"Sugar Mill\" to the plant \"Sugar Mill\". ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.set_process_plant!(database, \"Sugar Mill\", \"Sugar Mill\")","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now, let's define the remaining elements of the bioproducts chain. We will add the products \"Straw\", \"Ethanol 1G\", and \"Ethanol 2G\" to the database. We will also add the plant \"Ethanol Plant\" and the process \"Integrated ethanol production\" that converts sugarcane and straw into first and second generation ethanol. Finally, we will link the process to the plant. Here is the code:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.add_product!(\n    database;\n    label = \"Straw\",\n    unit = \"t\",\n    initial_availability = 100.0,\n)\n\nOptBio.add_product!(\n    database;\n    label = \"Ethanol 1G\",\n    unit = \"kL\",\n    sell_price = 0.5,\n)\n\nOptBio.add_product!(\n    database;\n    label = \"Ethanol 2G\",\n    unit = \"kL\",\n    sell_price = 0.7,\n)\n\nOptBio.add_plant!(\n    database;\n    label = \"Ethanol Plant\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n)\n\nOptBio.add_process!(\n    database;\n    label = \"Integrated ethanol production\",\n    opex = 0.0,\n    product_input = [\"Sugarcane\", \"Straw\"],\n    factor_input = [1.0, 0.9],\n    product_output = [\"Ethanol 1G\", \"Ethanol 2G\"],\n    factor_output = [7.5, 6.0],\n)\n\nOptBio.set_process_plant!(database, \"Integrated ethanol production\", \"Ethanol Plant\")","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"After defining the bioproducts chain, close the database using the close_database! function. This function receives the database object as an argument. In the code below, we close the database.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"OptBio.close_database!(database)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now the bioproducts chain is defined and saved in the file my_chain.optbio. To optimize the investments and operations of the chain, use the main function. This function receives a vector with the arguments of the execution, including the path of the .optbio file. The function returns a tuple with two elements: the first element is a dictionary with the inputs of the optimization, and the second element is a dictionary with the results of the optimization. In the code below, we optimize the chain defined in the file my_chain.optbio.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"inputs, solution = OptBio.main([filename])","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Some results can be accessed in the solution dictionary. In the code below, we show the capacity of the plants, the investments made in each plant, and the amount of each product sold. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia> @show solution[\"capacity\"];\nsolution[\"capacity\"] = [100.0, 0.0]\n\njulia> @show solution[\"investment\"];\nsolution[\"investment\"] = [52000.0, 0.0]\n\njulia> @show solution[\"sell\"];\nsolution[\"sell\"] = [75.0; 0.0; 0.0; 0.0; 0.0;;]","category":"page"},{"location":"api.html#OptBio","page":"API Reference","title":"OptBio","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"This page lists the functions available in the OptBio module.","category":"page"},{"location":"api.html#create_case","page":"API Reference","title":"create_case","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.create_case","category":"page"},{"location":"api.html#OptBio.create_case","page":"API Reference","title":"OptBio.create_case","text":"OptBio.create_case(path_db::String; kwargs...)\n\nCreate a case for the OptBio model.\n\nArguments\n\npath_db::String: Path to the database.\nkwargs...: Keyword arguments for the database creation and study configurations.\nFor the database creation, the following keyword arguments are available:\nforce::Bool: If true, the database is created even if it already exists. Default is false.\npath_migrations_directory::String: Path to the migrations directory. Suggestions: use OptBio.optbio_migrations_dir() to get the migrations directory.\nFor the study configurations, the following keyword arguments are available:\nscenarios::Int: Number of uncertainty scenarios. Default is 1.\nsolution_method::Int: Solution method. Fulfill with 0 for deterministic equivalent, 1 for Benders decomposition. Default is 1.\nminimum_iterations::Int: Minimum number of iterations for the Benders decomposition. Default is 3.\nmaximum_iterations::Int: Maximum number of iterations for the Benders decomposition. Default is 15.\nwrite_lp: If 1, the LP files are written. Default is 0.\n\nReturns\n\ndb::DatabaseSQLite: Database for the OptBio model.\n\nExample\n\ndb = OptBio.create_case(\n    \"directory_of_the_case/my_case.optbio\";\n    force = true,\n    path_migrations_directory = OptBio.optbio_migrations_dir(),\n    scenarios = 3,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#add_product!","page":"API Reference","title":"add_product!","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.add_product!","category":"page"},{"location":"api.html#OptBio.add_product!","page":"API Reference","title":"OptBio.add_product!","text":"OptBio.add_product!(db::DatabaseSQLite; kwargs...)\n\nAdd a product to the database.\n\nArguments\n\ndb::DatabaseSQLite: Database.\nkwargs...: Keyword arguments with the product attributes.\n\nThe following attributes are available:\n\nlabel::String: Product label.\nunit::String: Product unit.\ninitial_availability::Float64: Initial availability of the product for a year. Default is 0.0.\nsell_limit::Float64: Maximum amount of the product that can be sold within a year. Can be left empty.\nsell_price::Float64: Price of the product, based on its unit. Default is 0.0, meaning the product is not for sale.\nminimum_sell_quantity::Float64: Minimum amount of the product that can be sold within a year. Default is 0.0.\nminimum_sell_violation_penalty::Float64: Penalty for violating the minimum sell quantity. Needs to be fulfilled if minimum_sell_quantity is greater than zero.\n\nExample\n\nOptBio.add_product!(\n    db;\n    label = \"Sugar\",\n    sell_price = 5000.0,\n    unit = \"ton\",\n)\n\nOptBio.add_product!(\n    db;\n    label = \"Sugarcane\",\n    unit = \"ton\",\n    initial_availability = 100.0,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#add_plant!","page":"API Reference","title":"add_plant!","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.add_plant!","category":"page"},{"location":"api.html#OptBio.add_plant!","page":"API Reference","title":"OptBio.add_plant!","text":"OptBio.add_plant!(db::DatabaseSQLite; kwargs...)\n\nAdd a plant to the database.\n\nArguments\n\ndb::DatabaseSQLite: Database.\nkwargs...: Keyword arguments with the plant attributes.\n\nThe following attributes are available:\n\nlabel::String: Plant label.\ninitial_capacity::Float64: Initial capacity of the plant for a year. Default is 0.0.\nreference_capex::Float64: Capex of a reference plant.\nreference_capacity::Float64: Capacity of the reference plant.\nscaling_factor::Float64: Factor to scale the relation between capacity and capex according to the reference plant. Default is 0.7.\ninterest_rate::Float64: Annual interest rate for the Capex. Default is 0.1.\nlifespan::Int: Years of lifespan for the plant. Defines the amount of installment payments for the Capex. Default is 20.\nmaximum_capacity::Float64: Maximum capacity of the plant for a year. Can be left empty.\nmaximum_capacity_for_scale::Float64: Maximum capacity of the plant at which the scaling factor is applied. After this capacity, the Capex is linearly scaled with the capacity. Can be left empty.\n\nExample\n\nOptBio.add_plant!(\n    db;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 52000.0,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#add_process!","page":"API Reference","title":"add_process!","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.add_process!","category":"page"},{"location":"api.html#OptBio.add_process!","page":"API Reference","title":"OptBio.add_process!","text":"add_process!(db::DatabaseSQLite; kwargs...)\n\nAdd a process to the database.\n\nArguments\n\ndb::DatabaseSQLite: Database.\nkwargs...: Keyword arguments with the process attributes.\n\nThe following attributes are available:\n\nlabel::String: Process label.\nopex::Float64: Operating expense, based the amount of the first product in the input vector that is being processed.\nproduct_input::Vector{String}: Input product labels.\nfactor_input::Vector{Float64}: Vector of factors at which the input products are consumed. Must be ordered according to product_input. Each factor is based on the unit of the corresponding product.\nproduct_output::Vector{String}: Output product labels.\nfactor_output::Vector{Float64}: Vector of factors at which the output products are produced. Must be ordered according to product_output, and follow proportions to match inputs_factor. Each factor is based on the unit of the corresponding product.\n\nExample\n\nOptBio.add_process!(\n    db;\n    label = \"Sugar Mill\",\n    opex = 0.0,\n    product_input = [\"Sugarcane\"],\n    factor_input = [1.0],\n    product_output = [\"Sugar\"],\n    factor_output = [0.75],\n)\n\nAfter creating the process, it is necessary to associate it with a plant. This can be done with the set_process_plant! function.\n\n\n\n\n\n","category":"function"},{"location":"api.html#set_process_plant!","page":"API Reference","title":"set_process_plant!","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.set_process_plant!","category":"page"},{"location":"api.html#OptBio.set_process_plant!","page":"API Reference","title":"OptBio.set_process_plant!","text":"OptBio.set_process_plant!(db::DatabaseSQLite, process_label::String, plant_label::String)\n\nSet the plant associated with a process.\n\nExample\n\nOptBio.set_process_plant!(db, \"Sugar Mill\", \"Sugar Mill\")\n\n\n\n\n\n","category":"function"},{"location":"api.html#add_sum_of_products_constraint!","page":"API Reference","title":"add_sum_of_products_constraint!","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.add_sum_of_products_constraint!","category":"page"},{"location":"api.html#OptBio.add_sum_of_products_constraint!","page":"API Reference","title":"OptBio.add_sum_of_products_constraint!","text":"add_sum_of_products_constraint!(db::DatabaseSQLite; kwargs...)\n\nAdd a sum of products constraint to the database.\n\nArguments\n\ndb::DatabaseSQLite: Database\nkwargs...: Keyword arguments with the sum of products constraint attributes.\n\nThe following attributes are available:\n\nlabel::String: Sum of products constraint label.\nproduct_id::Vector{String}: Vector with labels of products to be included in the sum of products constraint.\nsell_limit::Float64: Sell limit for the sum of products in the vector.\n\nExample\n\nOptBio.add_sum_of_products_constraint!(\n    db;\n    label = \"Ethanol\",\n    product_id = [\"Ethanol 1G\", \"Ethanol 2G\"],\n    sell_limit = 2000.0,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#write_scenarios","page":"API Reference","title":"write_scenarios","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.write_scenarios","category":"page"},{"location":"api.html#OptBio.write_scenarios","page":"API Reference","title":"OptBio.write_scenarios","text":"OptBio.write_scenarios(\n    product_label::Vector{String},\n    product_unit::Vector{String},\n    path::String,\n    S::Int,\n    initial_availability::Matrix{Float64},\n    sell_price::Matrix{Float64},\n)\n\nWrite scenarios attributes values to CSV files.\n\nArguments\n\nproduct_label::Vector{String}: Product labels.\nproduct_unit::Vector{String}: Product units.\npath::String: The path of the directory where the CSV files will be written.\nS::Int: Number of scenarios.\ninitial_availability::Matrix{Float64}: Initial availability of the products for each scenario.\nsell_price::Matrix{Float64}: Sell price of the products for each scenario.\n\nExample\n\nproduct_label = [\"Sugar\", \"Sugarcane\"]\nproduct_unit = [\"ton\", \"ton\"]\n\nprice_scenarios = [\n    5000.0 0.0\n    4000.0 0.0\n    3000.0 0.0\n]\n\ninitial_availability_scenarios = [\n    0.0 100.0\n    0.0 150.0\n    0.0 80.0\n]\n\nOptBio.write_scenarios(\n    product_label,\n    product_unit,\n    \"directory_of_the_case\",\n    3,\n    initial_availability_scenarios,\n    price_scenarios,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#main","page":"API Reference","title":"main","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"OptBio.main","category":"page"},{"location":"api.html#OptBio.main","page":"API Reference","title":"OptBio.main","text":"OptBio.main(args::Vector{String})\n\nMain function to run the OptBio model.\n\nArguments\n\nargs::Vector{String}: Vector with arguments to be parsed. The only argument is the path to the database file.\n\nOutputs\n\nAfter running the model, a results folder will be created in the same directory as the database file. This folder will contain:\n\nCSV files containing the solution of the optimization model.\nA dashboard with the main results.\nA flowchart with the whole production chain and the path chosen by the optimization model.\n\nExample\n\nOptBio.main([\"directory_of_the_case/my_case.optbio\"])\n\n\n\n\n\n","category":"function"},{"location":"optimization.html#Model","page":"Mathematical Model","title":"Model","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"OptBio runs a model that aims to maximize the expected profit of the defined production chain, considering the uncertainty associated with the availability of the basis product and the selling prices of the bioproducts. According to the input parameters, the model will define the capacity and the associated investment in each industrial plant, as well as the amount of each bioproduct to be produced and sold. The model can be decomposed into two stages: the investment stage and the operation stage. In the deterministic equivalent solution method, one model is created, including all variables and constraints of both stages. In the Benders solution method, the stages are defined and solved separately, and the communication between them is made through Benders cuts. The master variable is the capacity of each industrial plant. The details of each stage of the model are presented below.","category":"page"},{"location":"optimization.html#Investment-model","page":"Mathematical Model","title":"Investment model","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"The Investment model is the stage in charge of defining the capacity and the investment associated with each industrial plant. The model aims to minimize the annuities of the investments in the plants and, in the Benders solution method, the expected value of the future costs.  ","category":"page"},{"location":"optimization.html#Sets","page":"Mathematical Model","title":"Sets","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"K: set of plants\nS: set of scenarios","category":"page"},{"location":"optimization.html#Constants","page":"Mathematical Model","title":"Constants","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"B^ref_k: capex of a reference plant\nC^ref_k: capacity of a reference plant\nC^0_k: plant initial capacity\nsigma_k: plant scaling factor\nr_k: plant annual interest rate\nn_k: plant number of years of lifespan\noverlineC_k: plant maximum capacity, defined by the user\noverlineoverlineC_k: plant maximum reachable capacity, calculated according to input products availability\noverlineC^sigma_k: plant capacity threshold for scale economy\nhatQ_s: evaluated future cost\nhatC_k s: evaluated capacity\nhatlambda_k s: evaluated marginal cost of capacity constraints\nm: number of pieces for piecewise linearization\nq: ratio at which each piece increases","category":"page"},{"location":"optimization.html#Decision-Variables","page":"Mathematical Model","title":"Decision Variables","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_k: plant capacity\nB_k: plant investment\nA_k: plant annuity\nQ_s: future cost","category":"page"},{"location":"optimization.html#Others","page":"Mathematical Model","title":"Others","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"dotC_kp: plant capacity values for piecewise linearization\ndotB_kp: plant investment values for piecewise linearization","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"The original relation between the variables of investment B_k and capacity C_k is exponential, as shown below:","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" B_k = B^ref_k cdot left( fracC_kC^ref_k right) ^sigma_k  ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"It expresses the scale economy of the plants. A intuitive way to understand it is to think that if the capacity of a plant is doubled, the investment associated is less than double, and if the capacity is halved, the investment is more than halved.","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"When there is a pre-existing capacity C^0_k, the investment associated with C_k^0 is subtracted from the investment associated with the total capacity C_k:","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" B_k = B^ref_k cdot left( fracC_kC^ref_k right) ^sigma_k - B^ref_k cdot left( fracC_k^0C^ref_k right) ^sigma_k ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"The function is both nonlinear as nonconvex. In order to linearize it, the capacity domain is divided into m pieces, defined by m + 1 points. The investment is evaluated at each point, and a linear function connects each pair of points. To reduce approximation errors, the points are defined by a geometric progression, with a ratio 1 + q. This way, the points are more concentrated in the lower capacity values, where the investment values are more sensitive to changes in capacity.","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" dotC_k0 = C^0_k    forall k in K ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" dotC_kp = C^0_k + ( textminoverlineoverlineC_k overlineC^sigma_k - C^0_k) cdot frac(1 + q)^p - 1(1+q)^m - 1     forall  p = 0dotsm  k in K ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" dotB_kp = B^ref_k cdot left( fracdotC_kpC^ref_k right) ^sigma_k - B^ref_k cdot left( fracC^0_kpC^ref_k right) ^sigma_k    forall  p = 0dotsm  k in K ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" dotC_km+1 = overlineoverlineC_k    forall k in K  textif  overlineC^sigma_k leq overlineoverlineC_k ","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":" dotB_km+1 = B^ref_k cdot left( fracdotC_kmC^ref_k right) ^sigma_k cdot fracdotC_km+1dotC_km - B^ref_k cdot left( fracC^0_kC^ref_k right) ^sigma_k\n    textif  overlineC^sigma_k leq overlineoverlineC_k ","category":"page"},{"location":"optimization.html#Objective-Function","page":"Mathematical Model","title":"Objective Function","text":"","category":"section"},{"location":"optimization.html#Deterministic-equivalent-solution-method","page":"Mathematical Model","title":"Deterministic equivalent solution method","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"minsum_k in K A_k","category":"page"},{"location":"optimization.html#Benders-solution-method","page":"Mathematical Model","title":"Benders solution method","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"The annuities are added to the objective function in both solution methods.","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"minsum_k in K A_k + frac1S sum_s in S Q_s","category":"page"},{"location":"optimization.html#Constraints","page":"Mathematical Model","title":"Constraints","text":"","category":"section"},{"location":"optimization.html#Relation-between-investment-and-plant-capacity","page":"Mathematical Model","title":"Relation between investment and plant capacity","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"(C_k B_k) in textpiecewise( dotC_kp dotB_kp _p = 0^m)    forall k in K","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint guarantees that the pair (C_k B_k) belongs to some linear segment defined by the points  dotC_kp dotB_kp _p = 0^m.","category":"page"},{"location":"optimization.html#[Plant](plant.md)-existing-capacity","page":"Mathematical Model","title":"Plant existing capacity","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_k geq C^0_k    k in K","category":"page"},{"location":"optimization.html#[Plant](plant.md)-capacity-limit","page":"Mathematical Model","title":"Plant capacity limit","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_k leq overlineC_k    forall k in K","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint is only active if the user defines a maximum capacity for the plant.","category":"page"},{"location":"optimization.html#[Plant](plant.md)-annuity-calculation","page":"Mathematical Model","title":"Plant annuity calculation","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"A_k = fracB_k cdot r_k1 - (1 + r_k)^-n_k    forall k in K","category":"page"},{"location":"optimization.html#Operation-model","page":"Mathematical Model","title":"Operation model","text":"","category":"section"},{"location":"optimization.html#Sets-2","page":"Mathematical Model","title":"Sets","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"I: set of products\nJ: set of processes\nK: set of plants\nG: set of sets of products with a sales limit in their sum\nS: set of scenarios\nI(g): set of products in set g. g in G. I(g) subseteq I.\nI^in(j): set of products as an input of process j\nI^out(j): set of products as an output of process j\nJ^c(i): set of processes consuming product i\nJ^p(i): set of processes producing product i\nJ(k): set of processes in plant\nu(j): function mapping process to its first input product","category":"page"},{"location":"optimization.html#Constants-2","page":"Mathematical Model","title":"Constants","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"c_j: process operational costs\np_i s: product sell price\noverlinev_i: product sell limit\nunderlinev_i: product minimum amount to be sold\nomega_i: penalty for product minimum amount to be sold violation\noverlinew_g: sales limit for the sum of products in set g\nD^0_is: product initial availability\nC^0_k: plant initial capacity\noverlineC_k: plant maximum capacity\ntheta^in_j i: factor of product i being consumed by process j\ntheta^out_j i: factor of product i being produced by process j\nhatC_k: evaluated capacity","category":"page"},{"location":"optimization.html#Decision-Variables-2","page":"Mathematical Model","title":"Decision Variables","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"D^f_i s: product final availability\nf^in_j i s: amount of product i going into process j\nf^out_j i s: amount of product i going out of process j\nl_j s: auxiliar variable for keeping proportions of process\nv_i s: product sell amount\nC_k s: plant capacity\nlambda_k s: marginal cost of capacity constraints\nQ_s: future cost\ndelta_is: slack for product minimum amount to be sold","category":"page"},{"location":"optimization.html#Objective-Function-2","page":"Mathematical Model","title":"Objective Function","text":"","category":"section"},{"location":"optimization.html#Deterministic-equivalent-solution-method-2","page":"Mathematical Model","title":"Deterministic equivalent solution method","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"In the deterministic equivalent solution method, is added to the objective function defined in the Investment model the expected value of the future costs.","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"+ frac1S sum_s in S Q_s","category":"page"},{"location":"optimization.html#Benders-solution-method-2","page":"Mathematical Model","title":"Benders solution method","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"minfrac1S sum_s in S Q_s","category":"page"},{"location":"optimization.html#Constraints-2","page":"Mathematical Model","title":"Constraints","text":"","category":"section"},{"location":"optimization.html#Costs-calculation","page":"Mathematical Model","title":"Costs calculation","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"Q_s = sum_j in J c_j cdot f^in_ju(j) - sum_i in I p_i s cdot v_i s + sum_i in I omega_i cdot delta_is    forall s in S","category":"page"},{"location":"optimization.html#[Product](product.md)-availability","page":"Mathematical Model","title":"Product availability","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"D^f_i s = D^0_is + sum_j in J^p(i) f^out_j i s - sum_j in J^c(i) f^in_jis - v_is    forall i in I s in S","category":"page"},{"location":"optimization.html#[Process](process.md)-proportions","page":"Mathematical Model","title":"Process proportions","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"l_js = frac1theta^in_ji cdot f^in_jis    forall s in S j in J i in I^in(j)","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"l_js = frac1theta^out_ji cdot f^out_jis    forall s in S j in J i in I^out(j)","category":"page"},{"location":"optimization.html#Plant-capacity-limit,-based-on-the-first-product-associated-with-the-process","page":"Mathematical Model","title":"Plant capacity limit, based on the first product associated with the process","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"sum_j in J(k) f^in_ju(j)s leq C_ks     forall s in S k in K","category":"page"},{"location":"optimization.html#Capacity-fishing-constraint:","page":"Mathematical Model","title":"Capacity fishing constraint:","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_ks = hatC_k    lambda_ks     forall s in S k in K","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint guarantees that the plant capacity in the operational model is equal to the plant capacity in the investment model, and it catches the marginal cost of capacity constraints, which is used in the Benders cuts.","category":"page"},{"location":"optimization.html#[Plant](plant.md)-existing-capacity-2","page":"Mathematical Model","title":"Plant existing capacity","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_ks geq C^0_k    forall s in S k in K","category":"page"},{"location":"optimization.html#[Product](product.md)-sell-limit","page":"Mathematical Model","title":"Product sell limit","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"v_is leq overlinev_i    forall i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint is only active if the product has a sell limit.","category":"page"},{"location":"optimization.html#[Product](product.md)-sell-lower-bound","page":"Mathematical Model","title":"Product sell lower bound","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"v_is geq underlinev_i - delta_is    forall i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint is only active if the product has a minimum amount to be sold.","category":"page"},{"location":"optimization.html#[Product](product.md)-sell-unavailability","page":"Mathematical Model","title":"Product sell unavailability","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"v_is = 0    forall i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"This constraint is only active if the product sell price is zero.","category":"page"},{"location":"optimization.html#Sales-limit-for-the-[sum-of-products-in-each-set](sum_of_products_constraint.md)","page":"Mathematical Model","title":"Sales limit for the sum of products in each set","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"sum_i in I^overlinev_g v_is leq overlinev_g    forall g in I^overlinev s in S","category":"page"},{"location":"optimization.html#Positive-amount-constraints","page":"Mathematical Model","title":"Positive amount constraints","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"D^f_i s geq 0    forall i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"f^in_jis geq 0    forall j in J i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"f^out_jis geq 0    forall in J i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"v_i s geq 0    forall i in I s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_k s geq 0    forall k in K s in S","category":"page"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"delta_is geq 0    forall i in I s in S","category":"page"},{"location":"optimization.html#Communication-between-stages","page":"Mathematical Model","title":"Communication between stages","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"In the Benders solution method, the Investment model and the Operation model are solved iteratively, and the communication between them is made through Benders cuts. The Benders cuts are added to the Investment model, and they are based on the evaluated capacity hatC_k s, operational cost hatQ_s and marginal cost of capacity constraints hatlambda_k s. Also, the evaluated capacity of the Investment Model is updated in the fishing constraint of the Operation model.","category":"page"},{"location":"optimization.html#Benders-cuts","page":"Mathematical Model","title":"Benders cuts","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"Q_s geq hatQ_s + sum_k in K hatlambda_k s cdot (C_k - hatC_k s)    forall s in S","category":"page"},{"location":"optimization.html#Fishing-constraint-update","page":"Mathematical Model","title":"Fishing constraint update","text":"","category":"section"},{"location":"optimization.html","page":"Mathematical Model","title":"Mathematical Model","text":"C_ks = hatC_k    lambda_ks     forall s in S k in K","category":"page"},{"location":"product.html#Product","page":"Product","title":"Product","text":"","category":"section"},{"location":"product.html","page":"Product","title":"Product","text":"A product is an element that can be sold, or used to produce other products. The user can define a product in the database using the OptBio.add_product! function. The essential parameters for the product definition are the label and the unit. It is also necessary to pass the database object as the first argument. ","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"OptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    unit = \"t\",\n)","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"The optional attributes for the product are all listed in this section.","category":"page"},{"location":"product.html#Initial-Availability","page":"Product","title":"Initial Availability","text":"","category":"section"},{"location":"product.html","page":"Product","title":"Product","text":"The user can define the initial availability of the product using the initial_availability parameter. The default value is 0.0.","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"OptBio.add_product!(\n    database;\n    label = \"Sugarcane\",\n    unit = \"t\",\n    initial_availability = 100.0,\n)","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"At least one product must have an initial availability greater than zero. ","category":"page"},{"location":"product.html#Sell-Price","page":"Product","title":"Sell Price","text":"","category":"section"},{"location":"product.html","page":"Product","title":"Product","text":"The sell price of the product is defined using the sell_price parameter. The default value is 0.0. There must be at least one product with a sell price greater than zero.","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"OptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    unit = \"t\",\n    sell_price = 5000.0,\n)","category":"page"},{"location":"product.html#Sell-Limit","page":"Product","title":"Sell Limit","text":"","category":"section"},{"location":"product.html","page":"Product","title":"Product","text":"The user can define the maximum amount of the product that can be sold using the sell_limit parameter. If no limit is defined, no limit is considered.","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"OptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    unit = \"t\",\n    sell_price = 5000.0,\n    sell_limit = 100.0,\n)","category":"page"},{"location":"product.html#Minimum-Sell-Quantity","page":"Product","title":"Minimum Sell Quantity","text":"","category":"section"},{"location":"product.html","page":"Product","title":"Product","text":"The user can define the minimum amount of the product that must be sold using the minimum_sell_quantity parameter. The default value is 0.0, meaning that there is no minimum quantity to be sold. ","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"If the user defines a minimum sell quantity, they must also define a penalty for not selling the minimum quantity. The penalty is defined using the minimum_sell_violation_penalty parameter. ","category":"page"},{"location":"product.html","page":"Product","title":"Product","text":"OptBio.add_product!(\n    database;\n    label = \"Sugar\",\n    unit = \"t\",\n    sell_price = 5000.0,\n    minimum_sell_quantity = 50.0,\n    minimum_sell_violation_penalty = 1000.0,\n)","category":"page"},{"location":"sum_of_products_constraint.html#Sum-of-Products-Constraint","page":"Sum of products constraint","title":"Sum of Products Constraint","text":"","category":"section"},{"location":"sum_of_products_constraint.html","page":"Sum of products constraint","title":"Sum of products constraint","text":"An optional element that can be added to the database is the sum of products constraint. It is a set of products that has a limit in their sum. The available limit is for the sell quantity of the products. It is designed to represent products that are not the same, but share a limited market.","category":"page"},{"location":"sum_of_products_constraint.html","page":"Sum of products constraint","title":"Sum of products constraint","text":"The user can define a sum of products constraint using the OptBio.add_sum_of_products_constraint! function. The function receives the database object, the label of the products set, the limit for the sell quantity, and the list of products that are part of the set. ","category":"page"},{"location":"sum_of_products_constraint.html","page":"Sum of products constraint","title":"Sum of products constraint","text":"OptBio.add_sum_of_products_constraint!(\n    database;\n    label = \"Sugar\",\n    product_id = [\"Crystal Sugar\", \"Refined Sugar\"],\n    sell_limit = 15000000.0,\n)","category":"page"},{"location":"configuration.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"While creating a optbio database, using the OptBio.create_case function, the user can set parameters for the model execution.","category":"page"},{"location":"configuration.html#Number-of-scenarios","page":"Configuration","title":"Number of scenarios","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"It is possible to define a number of uncertainty scenarios for the model, according to the number of scenarios defined, the user must provide different values for the products' sell price and initial availability. The user can define the number of scenarios using the scenarios parameter.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"filename = \"my_optbio_case_folder/my_chain.optbio\"\nOptBio.create_case(filename; scenarios = 3)","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"If the user does not define the number of scenarios, the default value is 1, and the user does not need to provide any scenario files.","category":"page"},{"location":"configuration.html#Solution-Method","page":"Configuration","title":"Solution Method","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"The user can define the solution method for the optimization problem using the solution_method parameter. The available methods are the Bender's Decomposition and the Deterministic Equivalent Formulation. The default method is the Bender's Decomposition.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"filename = \"my_optbio_case_folder/my_chain.optbio\"\nOptBio.create_case(filename; solution_method = OptBio.SolutionMethod.DETERMINISTIC)","category":"page"},{"location":"configuration.html#Bounds-for-number-of-iterations","page":"Configuration","title":"Bounds for number of iterations","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"The user can define the minimum and maximum number of iterations for the Bender's Decomposition method using the minimum_iterations and maximum_iterations parameters. The default values are 3 and 15, respectively.","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"filename = \"my_optbio_case_folder/my_chain.optbio\"\nOptBio.create_case(filename; minimum_iterations = 5, maximum_iterations = 20)","category":"page"},{"location":"configuration.html#LP-Writing","page":"Configuration","title":"LP Writing","text":"","category":"section"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"The user can choose to write the LP files for the model using the write_lp parameter. The default value is 0 (false).","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"filename = \"my_optbio_case_folder/my_chain.optbio\"\nOptBio.create_case(filename; write_lp = 1)","category":"page"},{"location":"configuration.html","page":"Configuration","title":"Configuration","text":"After the execution of the model, the LP files will be written in \"myoptbiocasefolder/simulationlogs\".","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<! <img src=\"assets/logo-with-name.png\" alt=\"OptBio logo\"/> >","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"OptBio is a Julia package designed for modeling and optimizing the value of bioproducts. It employs stochastic optimization to account for uncertainties in product selling prices and variations in crop yields. The package determines the optimal investment, production capacity, and operation of industrial plants to maximize profit. Built on the JuMP modeling language, OptBio uses the HiGHS solver to address these optimization problems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Developed by PSR, a global provider of consulting services, computational modeling, and energy innovation, this package is part of a research and development initiative funded by Tevisa, a thermoelectric generation company in Brazil, and is aligned with the Brazilian government's R&D program (PD-16269-0123/2023). The project also involved collaboration with the Brazilian federal university UNIFEI. Considering the potential of bioproducts for decarbonization, OptBio was specifically utilized to model the sugarcane production chain with a focus on biofuels. More informations about the project can be found in the video (in portuguese).","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package, you can follow these steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Clone the repository:  bash  git clone https://github.com/psrenergy/OptBio.git\nNavigate to the package directory and activate the project environment:  bash  cd OptBio  julia --project\nOnce in the Julia REPL, instantiate the environment to set up the necessary dependencies:  ```julia  julia> import Pkg\njulia> Pkg.instantiate()  ```","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will configure everything you need to start using the package.","category":"page"},{"location":"index.html#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Users are encouraged to contributing by opening issues and opening pull requests. If you wish to implement a feature please follow  the JuMP Style Guide.","category":"page"},{"location":"plant.html#Plant","page":"Plant","title":"Plant","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"A plant is a facility that can realize a set of processes. The model will choose its capacity and the investment associated to it.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"The user can define a plant in the database using the OptBio.add_plant! function. The essential parameters for the plant definition are the label, the reference capacity, and the reference capital expenditure. It is also necessary to pass the database object as the first argument.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n)","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"The capacity of the plant is defined by the amount of the first input product that can be processed by the plant within a year. In the example above, if a process that has sugarcane as the first input product is linked to the plant \"Sugar Mill\", the reference capacity of the plant will be 100.0 tons of sugarcane per year.","category":"page"},{"location":"plant.html#Scaling-Factor","page":"Plant","title":"Scaling Factor","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"The relation between the chosen capacity and investment will be based on the reference capacity and reference capital expenditure of the plant. The relation is not linear, it considers the economies of scale. The scaling factor is defined by the user and it is used to calculate the investment associated with the chosen capacity. The scaling factor must be greater than zero, and it's default value is 0.7.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n    scaling_factor = 0.8,\n)","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"If the relation between the chosen capacity and investment is linear, the scaling factor must be set to 1.0. More details about the scaling factor can be found in the model definition.","category":"page"},{"location":"plant.html#Interest-Rate-and-Lifespan","page":"Plant","title":"Interest Rate and Lifespan","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"The user can define the interest rate and the lifespan of the plant using the interest_rate and lifespan parameters. The interest rate is the annual interest rate of the investment, and the lifespan is the number of years that the plant will be operational, which also define the number of years that the investment will be paid. The default values are 0.1 and 20, respectively.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n    interest_rate = 0.08,\n    lifespan = 25,\n)","category":"page"},{"location":"plant.html#Maximum-Capacity","page":"Plant","title":"Maximum Capacity","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"The user can limit the capacity that the model can choose for the plant using the maximum_capacity parameter. If no limit is defined, the model whatever capacity it finds optimal.  ","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n    maximum_capacity = 150.0,\n)","category":"page"},{"location":"plant.html#Maximum-Capacity-for-Scale","page":"Plant","title":"Maximum Capacity for Scale","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"When the capacity chosen by the model is too far from the reference capacity, the scale economy considered by the model can be unrealistic high. The user can define a maximum capacity for scale using the maximum_capacity_for_scale parameter. The model will still be able to choose a capacity greater than the maximum capacity for scale, but after that, the scale economy will be considered linear. More details about the maximum capacity for scale can be found in the model definition. When no limit is defined, the model will consider the scale economy for any capacity.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n    maximum_capacity_for_scale = 700.0,\n)","category":"page"},{"location":"plant.html#Initial-Capacity","page":"Plant","title":"Initial Capacity","text":"","category":"section"},{"location":"plant.html","page":"Plant","title":"Plant","text":"An initial capacity can be considered for the plant using the initial_capacity parameter. The model will consider the already existing capacity when operating the plant. Scale economy is considered for expanding the plant. The default value of this attribute is zero.","category":"page"},{"location":"plant.html","page":"Plant","title":"Plant","text":"OptBio.add_plant!(\n    database;\n    label = \"Sugar Mill\",\n    reference_capacity = 100.0,\n    reference_capex = 100000.0,\n    initial_capacity = 50.0,\n)","category":"page"}]
}
